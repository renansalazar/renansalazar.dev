---
 title: Domain Driven Design
 pubDate: Apr 06 2025
 heroImage: /img/ddd.jpg
 layout: ../../layouts/BlogLayout.astro
---

Con este blog pretendo extraer las ideas y conceptos que han sido reveladores para mi y tambien compartir la gran experiencia que ha sido para mi leer este genial libro. El libro contiene 17 capitulos, los cuales estan separados en 4 secciones, en mi opinion ningun capitulo es prescindible ni poco importante, creo que es muy notorio la intencion de cada capitulo y el porqu√© forma parte del libro. Para estructurar mejor las ideas separar√© las secciones tal cual lo hace el libro porque es bastante precisa.

Es importante mencionar que los terminos usados, no estoy muy seguro de la traduccion exacta al espa√±ol por lo que lo cual en algunos casos los mantendre igual que el libro original. Por otro lado hay muchos conceptos que solo son mencionados; sin embargo son super importantes, no me extender√© en ellos sino me desviaria mucho de la intencion de este blog.

## ‚ù§Ô∏è Poniendo el Modelo de Dominio a trabajar

La primera secci√≥n del libro sienta las bases de todo el enfoque de Domain-Driven Design. Aqu√≠, Evans nos muestra que el coraz√≥n de cualquier software no es la tecnolog√≠a, ni los frameworks, ni siquiera el c√≥digo: es la habilidad para resolver problemas relacionados con el dominio para los usuarios, es decir es el modelo del dominio que es esa representaci√≥n simplificada pero poderosa de la realidad que nos permite resolver problemas del mundo real. Una de las mejores analogias usadas en el libro, es que el modelo no es una copia fiel de la realidad, sino una versi√≥n de la misma, como una pel√≠cula üé¨ que captura solo lo relevante para el problema que queremos resolver. Pero tener un buen modelo no es suficiente; hay que usarlo en todo el proyecto. Esto significa unir dise√±o y c√≥digo, mantener una conversaci√≥n constante entre desarrolladores y expertos del negocio, y construir un Lenguaje Ubicuo que todos comprendan y usen. En otras palabras, no se trata de escribir c√≥digo mec√°nicamente, sino de aprender continuamente sobre el negocio, refinar nuestras ideas üí°, experimentar, y moldear el software como una expresi√≥n viva del conocimiento que vamos descubriendo. El modelo debe estar tan arraigado en el c√≥digo como en las conversaciones del equipo. Si todos entienden el modelo, lo usan, lo mejoran y lo viven, entonces s√≠ estamos poniendo el modelo a trabajar.

## üß± Los bloques de contruccion de un modelo basado en el modelo

En esta secci√≥n, el libro baja del avi√≥n conceptual y aterriza en el terreno t√©cnico. Evans presenta los bloques fundamentales con los que construimos modelos s√≥lidos y mantenibles en el c√≥digo. Aprendemos a diferenciar Entities, que tienen identidad propia y sobreviven al paso del tiempo (como un usuario o una orden), de los Value Objects, que no tienen identidad y solo describen algo (como una direcci√≥n o un rango de fechas). Tambi√©n entran en juego los Services, que representan operaciones importantes del dominio que no encajan en entidades ni objetos de valor, y deben estar nombrados con el Lenguaje Ubicuo. Luego, se introducen patrones para manejar el ciclo de vida de los objetos del dominio, donde aparecen los poderosos Aggregates (con sus ra√≠ces e invariantes), las Factories (que crean objetos complejos) y los Repositories (que permiten acceder a objetos persistidos como si vivieran en memoria).

Todo esto tiene un prop√≥sito mayor: evitar que la complejidad del software nos devore. Al usar estos patrones, reforzamos la integridad del modelo, lo mantenemos enfocado, aislado del caos exterior y m√°s alineado con el negocio. El resultado es un sistema m√°s comprensible, flexible y capaz de crecer sin romperse. Como dice Evans: dise√±ar software es una batalla constante contra la complejidad, y estos bloques son nuestras mejores armas. ‚öîÔ∏è

## üîç Refactorizando hacia una Visi√≥n M√°s Profunda

En esta secci√≥n, el libro se vuelve casi filos√≥fico: ya no se trata solo de tener un modelo "correcto", sino de perseguir un modelo m√°s profundo, expresivo y alineado con el coraz√≥n del dominio. Evans nos recuerda que los modelos √∫tiles no nacen perfectos: emergen iterativamente a trav√©s de conversaciones, descubrimientos y muchas refactorizaciones peque√±as que, eventualmente, pueden llevarnos a avances revolucionarios (los famosos *breakthroughs*). Refactorizar no es solo limpiar c√≥digo: es refinar el pensamiento del equipo, es transformar el conocimiento impl√≠cito en conceptos expl√≠citos y construir software que no solo funcione, sino que explique por qu√© funciona. Esta secci√≥n es un llamado a vivir en el dominio, escuchar el lenguaje que usamos y moldear el software como una historia que cobra sentido con cada cambio.

Tambi√©n se introduce el concepto de Supple Design (dise√±o maleable): un dise√±o que no se resiste al cambio, sino que lo invita. Para lograrlo, Evans propone pr√°cticas como interfaces que revelan intenci√≥n, funciones sin efectos secundarios, y estructuras con contornos conceptuales claros. Se habla de c√≥mo los nombres, las restricciones expl√≠citas, y hasta patrones como Strategy o Specification pueden hacer que el modelo sea m√°s expresivo y elegante. Esta secci√≥n es una oda a la creatividad aplicada al c√≥digo, y al valor de un dise√±o que no solo sea robusto, sino tambi√©n un placer de usar y extender.

## üåç Dise√±o Estrat√©gico

En esta √∫ltima secci√≥n, Evans cambia el foco del "dise√±o en el c√≥digo" al "dise√±o en el sistema completo". Cuando una aplicaci√≥n crece, no alcanza con tener un buen modelo: necesit√°s varios modelos bien organizados y equipos alineados para evitar el caos. Ac√° aparece uno de los conceptos m√°s potentes de todo DDD: el Bounded Context. En lugar de forzar un √∫nico modelo para todo, se define un l√≠mite claro donde un modelo tiene sentido, y se acepta que otros contextos usar√°n modelos diferentes, incluso con t√©rminos distintos. Para orquestar todo esto, se usan herramientas como el Context Map, que muestra c√≥mo los distintos contextos se relacionan entre s√≠ (por ejemplo, con estrategias como Shared Kernel, Anticorruption Layer o Separate Ways).

Tambi√©n se profundiza el concepto de destilaci√≥n del dominio, que ya ven√≠a apareciendo en cap√≠tulos anteriores, pero que ac√° se convierte en una estrategia formal para separar lo esencial del ruido en sistemas grandes y distribuidos. La clave est√° en identificar el Core Domain (donde vive el verdadero valor del negocio) y enfocarse en √©l, mientras que los subdominios gen√©ricos o de soporte pueden simplificarse, tercerizarse o reutilizar soluciones existentes. Adem√°s, se exploran estructuras a gran escala, como capas de responsabilidad, met√°foras o componentes enchufables, para organizar sistemas complejos sin perder la claridad. Finalmente, el libro cierra con una invitaci√≥n a aplicar todo esto de manera estrat√©gica y org√°nica, reconociendo que los grandes cambios no ocurren por decreto, sino a trav√©s de principios compartidos, comunicaci√≥n fluida y un dise√±o que evoluciona con el equipo y el dominio. Es una llamada a pensar como arquitectos de sistemas vivos, no como simples constructores de funciones.

## üéØ Conclusi√≥n

Domain-Driven Design no es solo una t√©cnica de modelado, es una forma de pensar el software con prop√≥sito. Nos recuerda que no construimos sistemas solo para que funcionen, sino para que *resuelvan problemas reales* con claridad y poder explicativo. Desde crear modelos que representen el negocio (no solo estructuras de datos), hasta dise√±ar c√≥digo que hable el mismo idioma que los expertos del negocio. Aprendemos que las mejores soluciones no se imponen: se descubren, se refinan, se destilan. Que un buen nombre vale tanto como una buena implementaci√≥n, y que las conversaciones con el negocio son tan importantes como los tests. Y quiz√°s lo m√°s importante: que los grandes sistemas no se construyen con recetas m√°gicas, sino con equipos que aprenden juntos, iteran sin miedo y dise√±an con intenci√≥n.
